
// Backend: server.js
require('dotenv').config();
const express = require('express');
const bodyParser = require('body-parser');
const fs = require('fs/promises'); // Use fs.promises for async file operations
const path = require('path');
const axios = require('axios'); // For making HTTP requests to NowPayments

const app = express();
const PORT = process.env.PORT || 3000;
const NOW_API_KEY = process.env.NOW_API_KEY;
const WEBHOOK_SECRET = process.env.WEBHOOK_SECRET; // Unique secret for your webhook

// Fixed exchange rates
const fixedRates = {
    "BTC": 165870,
    "ETH": 5909
};

// NowPayments currency mapping for target currencies (USDT TRC20/ERC20)
const nowPaymentsTargetCurrencies = {
    "USDTTRC20": "usdttrc20",
    "USDTERC20": "usdt", // NowPayments uses 'usdt' for ERC20 by default for USDT
};

const ordersFilePath = path.join(__dirname, 'orders.json');

app.use(bodyParser.json());
app.use(express.static(path.join(__dirname, 'public'))); // Serve static files from 'public' directory

// Helper function to read/write orders
async function readOrders() {
    try {
        const data = await fs.readFile(ordersFilePath, 'utf8');
        return JSON.parse(data);
    } catch (error) {
        if (error.code === 'ENOENT') {
            await fs.writeFile(ordersFilePath, JSON.stringify([]), 'utf8');
            return [];
        }
        throw error;
    }
}

async function writeOrders(orders) {
    await fs.writeFile(ordersFilePath, JSON.stringify(orders, null, 2), 'utf8');
}

// Route to create a new payment
app.post('/api/create-payment', async (req, res) => {
    const { coin, amount, usd_value, receive_method, receive_wallet } = req.body;

    // Basic validation
    if (!coin || !amount || isNaN(usd_value) || !receive_method || !receive_wallet) {
        return res.status(400).json({ error: "Missing required payment details." });
    }

    if (!fixedRates[coin]) {
        return res.status(400).json({ error: "Invalid coin selected." });
    }

    if (!nowPaymentsTargetCurrencies[receive_method]) {
        return res.status(400).json({ error: "Invalid receive method." });
    }

    const calculatedUsd = amount * fixedRates[coin];
    if (Math.abs(calculatedUsd - usd_value) > 0.01) { // Allow a small floating point difference
        return res.status(400).json({ error: "USD value mismatch. Please recalculate." });
    }

    try {
        const nowPaymentsPayload = {
            price_amount: usd_value.toFixed(2), // Amount in USD
            price_currency: 'usd',
            pay_currency: coin.toLowerCase(), // BTC, ETH (NowPayments expects lowercase)
            ipn_callback_url: ${process.env.BASE_URL}/webhook/payment?secret=${WEBHOOK_SECRET},
            order_id: OneCash_${Date.now()}_${Math.random().toString(36).substring(7)}, // Unique internal order ID
            order_description: Exchange ${amount} ${coin} to ${usd_value} USD,
            // customer_email: 'customer@example.com', // Optional
            // fixed_price: true, // Not strictly needed when using price_amount/currency
        };

        const nowPaymentsResponse = await axios.post('https://api.nowpayments.io/v1/payment', nowPaymentsPayload, {
            headers: {
                'x-api-key': NOW_API_KEY,
                'Content-Type': 'application/json'
            }
        });

        const nowPaymentData = nowPaymentsResponse.data;

        if (nowPaymentData.payment_id) {
            const orders = await readOrders();
            const newOrder = {
                order_id: nowPaymentData.order_id, // Use the order_id generated by us, or nowPaymentData.payment_id if preferred
                payment_id: nowPaymentData.payment_id, // Store NowPayments' payment ID
                coin: coin,
                amount: amount,
                usd_value: usd_value,
                receive_method: receive_method,
                receive_wallet: receive_wallet,
                status: nowPaymentData.payment_status || 'pending', // Initial status from NowPayments
                pay_address: nowPaymentData.pay_address,
                pay_amount: nowPaymentData.pay_amount, // Amount user needs to send in selected coin
                payment_url: nowPaymentData.payment_url,
                expiration_estimate_date: nowPaymentData.expiration_estimate_date,
                created_at: new Date().toISOString()
            };
            orders.push(newOrder);
            await writeOrders(orders);

            res.status(201).json({ order_id: newOrder.order_id });
        } else {
            console.error('NowPayments API Error:', nowPaymentData);
            res.status(500).json({ error: "Failed to create payment with NowPayments.", details: nowPaymentData });
        }

    } catch (error) {
        console.error('Error creating payment:', error.response ? error.response.data : error.message);
        res.status(500).json({ error: "An error occurred while processing your request.", details: error.response ? error.response.data : error.message });
    }
});

// Route to get payment details for payment.html
app.get('/api/payment-details', async (req, res) => {
    const { order_id } = req.query;

    if (!order_id) {
        return res.status(400).json({ error: "Order ID is required." });
    }

    try {
        const orders = await readOrders();
        const order = orders.find(o => o.order_id === order_id);

        if (!order) {
            return res.status(404).json({ error: "Order not found." });
        }
        res.status(200).json(order);
    } catch (error) {
        console.error('Error fetching payment details:', error);
        res.status(500).json({ error: "An error occurred while fetching payment details." });
    }
});

// Route to get current payment status (for polling on payment.html)
app.get('/api/payment-status', async (req, res) => {
    const { order_id } = req.query;

    if (!order_id) {
        return res.status(400).json({ error: "Order ID is required." });
    }

    try {
        const orders = await readOrders();
        const order = orders.find(o => o.order_id === order_id);

        if (!order) {
            return res.status(404).json({ error: "Order not found." });
        }

        // Optionally, you can call NowPayments API here to get the absolute latest status
        // For simplicity, we are returning the stored status, relying on webhook for updates
        res.status(200).json({ status: order.status });
    } catch (error) {
        console.error('Error fetching payment status:', error);
        res.status(500).json({ error: "An error occurred while fetching payment status." });
    }
});


// Webhook callback from NowPayments
app.post('/webhook/payment', async (req, res) => {
    const { secret } = req.query;

    // Validate webhook secret
    if (secret !== WEBHOOK_SECRET) {
        console.warn('Webhook received with invalid secret:', secret);
        return res.status(403).json({ error: "Forbidden: Invalid secret." });
    }

    // NowPayments sends a specific header for signature verification if enabled
    // const signature = req.headers['x-nowpayments-sig'];
    // For simplicity, we are skipping full signature verification here,
    // but in a production environment, you should verify the signature for security.
    // Example: https://nowpayments.io/doc/create-payment#ipn-call

    const nowPaymentData = req.body;
    console.log('Webhook received:', nowPaymentData);

    const { payment_id, payment_status, order_id } = nowPaymentData;

    if (!payment_id || !order_id || !payment_status) {
        console.error('Webhook payload missing essential fields:', nowPaymentData);
        return res.status(400).json({ error: "Invalid webhook payload." });
    }

    try {
        const orders = await readOrders();
        const orderIndex = orders.findIndex(o => o.payment_id === payment_id || o.order_id === order_id);

        if (orderIndex === -1) {
            console.warn('Webhook received for unknown order/payment ID:', payment_id, order_id);
            return res.status(404).json({ error: "Order not found for this webhook." });
        }

        const currentOrder = orders[orderIndex];

        // Update order status if it's a valid status change
        // NowPayments provides statuses like 'waiting', 'confirming', 'sending', 'partially_paid', 'finished', 'failed', 'refunded', 'expired'
        const validStatusUpdates = ['confirming', 'sending', 'partially_paid', 'finished', 'failed', 'refunded', 'expired'];

        // Only update if the new status is different and valid, or 'paid' (which is 'finished' for us)
        if (currentOrder.status !== payment_status && validStatusUpdates.includes(payment_status)) {
            currentOrder.status = payment_status === 'finished' ? 'paid' : payment_status; // Map 'finished' to 'paid'
            currentOrder.updated_at = new Date().toISOString();
            await writeOrders(orders);
            console.log(Order ${order_id} status updated to: ${currentOrder.status});
        } else if (currentOrder.status === 'pending' && payment_status === 'waiting') {
            // Keep 'pending' for 'waiting' status, no change needed unless we specifically want to log 'waiting'
        }
         else if (currentOrder.status === 'paid' && payment_status === 'finished') {
             // Already marked as paid, no further update needed for finished
         }

        res.status(200).json({ message: "Webhook processed successfully." });

    } catch (error) {
        console.error('Error processing webhook:', error);
        res.status(500).json({ error: "An error occurred while processing the webhook." });
    }
});

// Catch-all for undefined API routes
app.use('/api/*', (req, res) => {
    res.status(404).json({ error: "API route not found." });
});

// Serve frontend for any other routes (SPA fallback)
app.get('*', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// Error handling middleware
app.use((err, req, res, next) => {
    console.error(err.stack);
    res.status(500).send('Something broke!');
});

app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
    console.log(Access frontend at http://localhost:${PORT});
});